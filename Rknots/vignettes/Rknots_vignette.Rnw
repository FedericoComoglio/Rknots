%\VignetteIndexEntry{}
%\VignettePackage{Rknots}

\documentclass{article}

\usepackage{Sweave}
\usepackage[a4paper]{geometry}
\usepackage{hyperref,graphicx}
\usepackage{color}

\SweaveOpts{keep.source=TRUE,eps=TRUE,width=4,height=4.5} 
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\disc}[1]{\color{red} #1 \color{black}}
\renewcommand{\floatpagefraction}{0.7}	
\setkeys{Gin}{width=0.5\textwidth}
  
\author{Federico Comoglio$^1$ and Maurizio Rinaldi$^2$\\[1em] $^1$ D-BSSE, ETH Zurich, Basel, Switzerland\\ $^2$ DiSCAFF, University of Piemonte Orientale, Novara, Italy\\[1em]
\texttt{federico.comoglio@bsse.ethz.ch}}

\title{\textsf{\textbf{The \Rpackage{Rknots} package}}}

\begin{document}

\maketitle
\begin{abstract}
From a topological point of view, polymers can be modeled as open polygonal paths that upon closure generate topological objects called knots. Multi component knots are known as links. The \Rpackage{Rknots} package contains functions for the topological analysis of knots and links with a particular focus on biological polymers like proteins.\\
This vignette explains the use of the package and is divided in three main parts. The first one deals with structure import, the second is focused on the methods that have been implemented and the third one is a case study that illustrates how to use the general functions presented in the previous two sections for the analysis of proteins. For a more formal exposition of the methods, especially of the HOMFLY polynomial computation, please refer to~\cite{CR}. Should you have any question or suggestion, feel free to email us.\\
\end{abstract}

\tableofcontents

%--------------------------------------------------
\section{File import and input structure} 
%--------------------------------------------------

The \Rpackage{Rknots} package deals with knots and links and therefore it expects the coordinates of $N$ points in the three-dimensional space together with a set of integer separators as an input. It is worth to give a clear description of these two attributes. $N$ points in 3D can be naturally represented by a $N \times 3$ matrix, where each row is a point and the columns are the $x, y, z$ coordinates of that point. If the topological structure is a knot, then it will be entirely defined by its points. However, if we are dealing with links, a collection of knots where each single entity defines a component of the link, the coordinates matrix will not be sufficient. A vector $S$ of component separators (also ends) is then required to describe the boundaries between components. Notice that there is an arbitrary and potentially dangerous choice on the separators due to the duality points-edges. We defined each separator as the index of the edge that if not removed would connect a component with the following and that can thus be regarded as a 'phantom' edge. For example, the Hopf link represented in figure~\ref{fig:01} is defined by an $8 \times 3$ matrix and separator $S = 4$. The 'phantom' edge is indicated by the gray dashed line.
\begin{figure}[h]
\centering
\includegraphics{Rplotvignette1}
\caption{Polygonal Hopf link diagram. The component separator is $S=4$.}
\label{fig:01}
\end{figure}

%--------------------------------------------------
\subsection{Datasets} 
%--------------------------------------------------
\Rpackage{Rknots} comes along with two datasets containing 250 knots having less than 11 crossings and enumerated according to Rolfsen~\cite{Rolfsen} and 130 links up to 4 components. The 3D coordinates of knots are available as full representation or as minimal stickies representation and are stored in the dataset \Robject{Rolfsen.table}. The 3D coordinates of links and their separators are stored in the dataset \Robject{link.table}. Let's have a look at both datasets, that can be accomplished with the following commands:
<<loading>>=
library("Rknots")
data(Rolfsen.table)
str( head(Rolfsen.table, 5) )
@
Notice that each knot is an element of a list, and that a given knot can be accessed also by using its name. 
<<>>=
head( names(Rolfsen.table) )
@
For example, one can access the coordinates of the trefoil knot (knot $3_1$) using \Robject{Rolfsen.table['3.1']}.
<<knotex>>=
str( Rolfsen.table['3.1'] )
@
The minimal stickies coordinates of knots are stored in the \Robject{Rolfsen.table.ms} list, which has the same names of the full representation.
<<knotms>>=
str( head(Rolfsen.table.ms, 5) )
head( names(Rolfsen.table.ms) )
@	
Graphically, the difference between the full representation of a knot and the minimal stickies representation is illustrated in figure~\ref{fig:02} for the trefoil knot.
%
\setkeys{Gin}{width=0.8\textwidth} %%
\begin{figure}[h]
\centering
\includegraphics{Rplotvignette2}
\caption{Full and minimal stickies representation of the trefoil knot.}
\label{fig:02}
\end{figure}
\setkeys{Gin}{width=0.5\textwidth} %%
\newline
Links are stored in the \Robject{link.table} list. Each element of the list contains two slots, respectively the coordinates and separators of the link.
<<link>>=
data(link.table)
str( head(link.table, 5) )
head( names(link.table) )
@	
%--------------------------------------------------
\subsection{Example knots and links} 
%--------------------------------------------------
For the first two sections of this vignette, we will deal with an example knot and link sampled randomly from the above described datasets. To pick a structure it is sufficient to type
<<seed, echo = FALSE>>=
set.seed(123)
@

<<example>>=
knot <- makeExampleKnot(k = TRUE) #for a knot
link <- makeExampleKnot(k = FALSE) #for a link
@
This will turn out to be very convenient in the forthcoming sections, where we can use these structures to illustrate the core algorithms for structure reduction and polynomial invariants computation.
%--------------------------------------------------
\subsection{Create objects of class \Rclass{Knot}} 
%--------------------------------------------------
The main class in \Rpackage{Rknots} is an S4 class called  \Rclass{Knot}. The class has two slots:
\begin{enumerate}
	\item \Robject{points3D}: an $N$ x 3 matrix containing the $x$, $y$, $z$ coordinates of points
		of a polygonal knot or link. Each row contains the 3D coordinates of a single point of the structure. This slot is of type \Robject{matrix}.
	\item \Robject{ends}: a vector of integers containing the separators of the link components. This slot is by default set to \Robject{numeric(0)} for knots and is of type \Robject{numeric}.
\end{enumerate}
A new object of class \Rclass{Knot} can be created either using the generic constructor \Rfunction{new} or by means of the class constructor \Rfunction{newKnot}. The following example shows how to setup an object in both ways
<<class, eval =FALSE>>=
knot.cls <- new('Knot', points3D = knot)
link.cls <- new('Knot', points3D = link$points3D, ends = link$ends)
@
<<class1>>=
( knot.cls <- newKnot(points3D = knot) )
( link.cls <- newKnot(points3D = link$points3D, ends = link$ends) )
@
If wished, the method \Rfunction{print} (e.g. \Rfunction{print(link.cls)}) allows to visualize the full output. To access the two class slots one can make use of the accessors \Rfunction{getCoordinates} and \Rfunction{getEnds} or the \Rfunction{[} operator. The use of \Rfunction{@} is discouraged.
@
<<getters>>=
head( getCoordinates(knot.cls), 5 )
getEnds(knot.cls)
head( link.cls['points3D'], 5)
link.cls['ends']
@
Accordingly, the content of the slots can be modified using the setters \Rfunction{setCoordinates}, \Rfunction{setEnds} or via \Rfunction{[<-}. For example, let's modify the object \Robject{knot.cls} by replacing its coordinates with some randomly generated ones
<<setters>>=
knot.bu <- knot.cls #save the original
new.coordinates <- matrix( runif(60), ncol = 3 )
setCoordinates(knot.cls) <- new.coordinates
knot.cls
knot.cls <- knot.bu #back to the original
@
Let's now try to modify the separators of the object \Robject{link.cls}
<<>>=
link.bu <- link.cls #save the original
setEnds(link.cls) <- c(10, 50, 90)
getEnds(link.cls)
link.cls <- link.bu
@
Notice that it is not required to replace $n$ separators with $n$ new separators. Certainly this operation changes the link we are dealing with, but it is very useful when local operations on the link are performed, giving rise to a different link (for example, by merging together two components).\\
\paragraph{Remarks}
\Rpackage{Rknots} has been developed to give users the most general purpose framework possible. Theoretically, there is no a priori limitation on the structure to be loaded, neither in terms of points nor link components. Practically, this depends on the downstream analysis to be performed. The coordinates of a structure to be loaded can be read in \textsf{R} with commands like \Rfunction{read.table}, \Rfunction{read.delim}, \Rfunction{read.csv}, etc. See the relevant help pages for details.
%
%
%
%--------------------------------------------------
\section{Structure reduction and invariant computation} 
%--------------------------------------------------
Usually, the endpoint of the topological analysis of a knotted structure is the computation of an invariant, generally a polynomial and its computational cost is generally very high. Thus, a priori crucial step is to reduce the structure to a simpler form by reducing the number of point subject to the constraint of retaining all the topological information of the original structure. This is accomplished by applying structure reduction algorithms of knots and links~\cite{Reidemeister, Alexander}, described in the next section.
%--------------------------------------------------
\subsection{Structure reduction algorithms} 
%--------------------------------------------------
Two structure reduction algorithms have been implemented in \Rpackage{Rknots}: the Alexander-Briggs (AB) algorithm~\cite{Alexander} based on the elementary deformation and the Minimal Structure Reduction (MSR) algorithm~\cite{CR} based on the generalized Reidemeister moves. The former is very efficient whereas the latter, by working on the knot projection, contains intrinsically more information at the price of being slower.\\
Let's first examine how to apply these algorithms outside the context of the \Rclass{Knot} class. To reduce the knot we created, we can type
<<alexanderbriggs>>=
knot.AB <- AlexanderBriggs(points3D = knot, ends = c())
str(knot.AB)
knot.msr <- msr(points3D = knot, ends = c())
str(knot.msr)
@
\Rfunction{Alexander-Briggs} returns a list with the reduced structure, \Rfunction{msr} additionally returns the intersection matrix $M$, which contains the position and sign of the crossings in the structure. The original structure and the two reduced ones can be visualized by plotting a knot diagram with \Rfunction{plotDiagram}.
\begin{center}
<<fig = TRUE>>=
plotDiagram(knot, ends = c(), lwd = 2, main = 'Original Structure')
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth} %%
\begin{center}
<<fig = TRUE, width=8,height=4.5>>=
par( mfrow=c(1,2) )
plotDiagram(knot.AB$points3D, knot.AB$ends, lwd = 2, main = 'Reduced with Alexander-Briggs')
plotDiagram(knot.msr$points3D, knot.msr$ends, lwd = 2, main = 'Reduced with MSR')
@
\end{center}
 \setkeys{Gin}{width=0.5\textwidth} %%
The same applies to the reduction of the link we created before, in its naive application just requires to include the link separators by using
\begin{center}
<<fig = TRUE>>=
link.AB <- AlexanderBriggs(points3D = link$points3D, ends = link$ends)
str(link.AB)
link.msr <- msr(points3D = link$points3D, ends = link$ends)
str(link.msr)
plotDiagram(link$points3D, link$ends, lwd = 2, main = 'Original Structure')
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth} %%
\begin{center}
<<fig = TRUE, width=8,height=4.5>>=
par( mfrow=c(1,2) )
plotDiagram(link.AB$points3D, link.AB$ends, lwd = 2, main = 'Reduced with Alexander-Briggs')
plotDiagram(link.msr$points3D, link.msr$ends, lwd = 2, main = 'Reduced with MSR')
@
\end{center}
Notice that \Rfunction{msr} can be used for achieving a partial reduction by controlling the number of iterations \Robject{n} (default to 100).\\
An object of class \Rclass{Knot} can be reduced by means of the \Rfunction{reduceStructure} method, that takes a \Rclass{Knot} object and the algorithm to be applied as an input and returns an object of class \Rclass{Knot} containing the reduced structure:
<<classred>>=
knot.cls.AB <- reduceStructure(knot.cls, algorithm = 'AB' )
knot.cls.MSR <- reduceStructure(knot.cls, algorithm = 'MSR' )
link.cls.AB <- reduceStructure(link.cls, algorithm = 'AB' )
link.cls.MSR <- reduceStructure(link.cls, algorithm = 'MSR' )
link.cls.AB
@
The knot diagram can be drawn simply by using the method \Rfunction{plot} when the input is an \Rclass{Knot} object.
 \setkeys{Gin}{width=0.8\textwidth} %%
 \begin{center}
<<fig = TRUE, width=8,height=4.5>>=
par( mfrow = c(1, 2) )
plot(link.cls.AB, main = 'default') #default
plot(link.cls.AB, lend = 2, lwd = 3, main = 'using par()') #thicker overcrossings. 
#see par() for additional options
@
\end{center}
 \setkeys{Gin}{width=0.5\textwidth} %%
%--------------------------------------------------
\subsection{Computation of the invariants of knots and links} 
%--------------------------------------------------
\Rpackage{Rknots} can be used to compute the following invariants, listed according to the structure given as input.
\begin{itemize}
\item knots: Alexander, Jones and HOMFLY polynomials
\item links: Jones and HOMFLY polynomials, the multivariable Alexander polynomial and the linking number
\end{itemize}
In contrast to the previous section, we will only examine how to compute polynomial invariants with an object of class \Rclass{Knot}. We are currently working on the description on how the invariants are internally computed using low-level functions. Feel free to send us an email for a preliminary version. \\
Having an object of class \Rclass{Knot} the desired invariant can be computed with the function \Rfunction{computeInvariant} that internally discriminates between knots and links and returns the appropriate polynomial as follows:
<<classinv>>=
( delta.k <- computeInvariant( knot.cls.AB, invariant = 'Alexander') )
jones.k <- computeInvariant( knot.cls.AB, invariant = 'Jones', skein.sign = -1)
homfly.k <- computeInvariant( knot.cls.AB, invariant = 'HOMFLY', skein.sign = -1)
@
and analogously for the previously created link
<<classinv>>=
( delta.l <- computeInvariant( link.cls.AB, invariant = 'Alexander') )
jones.l <- computeInvariant( link.cls.AB, invariant = 'Jones', skein.sign = -1)
homfly.l <- computeInvariant( link.cls.AB, invariant = 'HOMFLY', skein.sign = -1)
@
The Jones and the HOMFLY polynomial of our sample knot and link are quite long and we printed the Alexander polynomial for sake of illustration. However, \Rpackage{Rknots} contains utilities to convert, when possible, a polynomial into another one. For example, we can convert the HOMFLY polynomial to the Jones polynomial by using
<<conversion>>=
converted <-HOMFLY2Jones( homfly.k )
identical( converted, jones.k)
@
For some applications, the linking number of a link is desired. The function \Rfunction{linkingNumber} in \Rpackage{Rknots} computes the linking number of a polygonal link simply by
<<>>=
( computeInvariant( link.cls.AB, invariant = 'LK') )
@
Before moving to the last session, let's make use of what we have described so far by reproducing a modern version of the very beginning of the original Rolfsen knot table.
<<Rolfsen, eval = FALSE>>=
data(Rolfsen.table)
text <- names(Rolfsen.table)[1 : 6]
par(mfrow = c(3,2))
for(i in 1 : 6) { 
  k <- Rolfsen.table[[i]]
  k <- newKnot(k)
  plot(k, lwd = 2, main = text[i], 
       sub = paste( computeInvariant(k, 'Alexander'), 
                    computeInvariant(k, 'Jones'),
                    computeInvariant(k, 'HOMFLY'), sep = '\n'))
}        
@
\setkeys{Gin}{width=0.8\textwidth} %%
\begin{center}
\includegraphics[scale = 2]{Rplotvignette3}
\end{center}
\setkeys{Gin}{width=0.5\textwidth} %%
%%
%--------------------------------------------------
\subsection{\Rpackage{Rknots} and protein knot analysis, a dedicated pipeline} 
%--------------------------------------------------
\Rpackage{Rknots} provides an optimized pipeline for detecting and characterizing knots in proteins and more generally in biopolymers. Two example \texttt{.pdb} files are part of the package data and will be partially used in the following case study.
\begin{enumerate}
\item the Rds3p protein (PDB identifier \texttt{2K0A}), a member of the U2 snRNP essential for pre-mRNA splicing, that has a left-handed trefoil knotted structure~\cite{vanRoon}
\item The first chain (A) of the E. Coli alkaline phosphatase (D153G mutant), as an example of protein presenting a structural gap, potential source of false positives.
\end{enumerate}
A protein can be loaded from the file system or fetched from the Protein Data Bank (citare PDB) using the \Rfunction{loadProtein} function. This function returns a list of matrices, where each element contains the 3D coordinates of a given protein chain. By default, \Rfunction{loadProtein} performs gap finding for each chain backbone, with a parameter \Robject{cutoff} that allow a custom definition of a gap. \Robject{cutoff} represents  the maximum allowed euclidean distance between two consecutive alpha-Carbon residues. If a distance is greater than \Robject{cutoff}, the chain is split in the corresponding position. The resulting subchains inherit the label from the chain that have been split, with an additional consecutive number for each of the subchain (e.g. if chain $A$ is split into three subchains, they will be labeled $A_1$, $A_2$ and $A_3$).
<<prot>>=
#from the file system
protein <- loadProtein(system.file("extdata/2k0a.pdb", package="Rknots"))
protein<- loadProtein('2K0A') #from the PDB
str(protein)
@
\Rfunction{loadProtein} can be called with any additional parameter of the \Rfunction{read.pdb} function of \Rpackage{bio3d}. See the relevant manual for details.\\
At this point, we may wish to visualize the 3D structure of the imported protein and the corresponding backbone model. For this purpose, we can use the function \Rfunction{plot3D} and exploit the superb graphics of \Rpackage{rgl}~\cite{rgl}. Particularly, we can supply parameters for the functions \Rfunction{lines3d} and \Rfunction{spheres3d}. Briefly, the code below will produce the desired plot. A snapshot is shown below. First, we prepare a color palette for each residue that will be passed as a list to the low-level function \Rfunction{plotKnot3D}. Its wrapper for an object of class \Rclass{Knot} is simply \Rfunction{plot3D} (notice the capital D) and requires the same parameters as \Rfunction{plotKnot3D}.
<<plot3D, eval = FALSE>>=
ramp <- colorRamp(c('blue', 'white', 'red'))
pal <- rgb( ramp(seq(0, 1, length = 109)), max = 255)
plotKnot3D(protein$A, colors = list( pal ), 
	lwd = 8, radius = .4, showNC = TRUE, text = TRUE)
@
The variable \Robject{showNC} labels the N-terminus and the C-terminus of the protein, whereas \Rfunction{text} add to each point the corresponding residue number. 
\setkeys{Gin}{width=0.6\textwidth} %%
\begin{center}
\includegraphics{Rplotvignette5}
\end{center}
\setkeys{Gin}{width=0.5\textwidth} %%
Although possible due to a fully customizable representation, to prepare high-quality figures for publications we recommend to export the structure using \Rfunction{write.pdb} and load the result into dedicated software for protein structure visualization.
\vskip5pt
To find knots in proteins, a single subunit has to be supplied and coerced to a \Rclass{Knot} class object. The available chains are simply the names of the list returned by \Rfunction{loadProtein} 
<<>>=
names(protein)
@
and the coercion can be simply achieved through:
<<>>=
protein <- newKnot(protein$A)
protein
@
After that, the structure has to be closed with the function \Rfunction{closeAndProject}, which also applies a Principal Component Analysis on the closed structure mostly to lead to optimized graphical representations and to minimize the possibility of numerical problems during the computation of the HOMFLY polynomial. 
<<>>=
protein.cp <- closeAndProject( protein, w = 2 )
@
where \Robject{w} controls the extension of the endpoints (we are using the default value in this example and generally, any value greater than 1 will do). Let's plot the two protein diagram for comparisons
<<plotprotein, eval = FALSE>>=
par(mfrow = c(1,2))
plot(protein, main = 'original', lwd = 2)
plot(protein.cp, main = 'closed & projected', lwd = 2)
@
\setkeys{Gin}{width=1\textwidth} %%
\begin{center}
\includegraphics{Rplotvignette4}
\end{center}
 \setkeys{Gin}{width=0.5\textwidth} %%
Now, we can make use of what we already know for computing the polynomial invariants of this protein:
<<protinv>>=
( delta.p <- computeInvariant( protein.cp, invariant = 'Alexander') )
( jones.p <- computeInvariant( protein.cp, invariant = 'Jones', skein.sign = -1) )
( homfly.p <- computeInvariant( protein.cp, invariant = 'HOMFLY', skein.sign = -1) )
@
As expected, the Alexander polynomial only tells us that we are dealing with a trefoil knot, but we can make use of the HOMFLY polynomial to establish the knot chirality. If you need support to determine the knot type, the function \Rfunction{getKnotType} does the characterization for you. The polynomial as returned by \Rfunction{computeInvariant}, the polynomial type and an optional additional parameter controlling the information to be returned are required as an input. For example we can characterize the knot type of the current protein with
<<getKT>>=
getKnotType(polynomial = delta.p, invariant = 'Alexander')
getKnotType(polynomial = homfly.p, invariant = 'HOMFLY')
getKnotType(polynomial = homfly.p, invariant = 'HOMFLY', full.output = TRUE)
@
It turns out that the Rds3p protein has a left-handed knot that we can compare with the mirror image of the polynomial of the right-handed trefoil knot in the Rolfsen knot table by means of another \Rpackage{Rknots} utility:
<<>>=
trefoil <- Rolfsen.table[[1]]
trefoil <- newKnot(trefoil)
( homfly.tr <- computeInvariant(trefoil, 'HOMFLY') )
( homfly.tl <- HOMFLY2mirror(homfly.tr) )
identical( homfly.p, homfly.tl )
@
Finally, notice that if a protein has more than one chain, to iterate over all the possible chains we can make use of \Rfunction{lapply}, as follows. First let's define two very simple functions. The first one can be used for processing a single chain and its very simple code summarizes what we have done so far, for example with the Rds3p protein above. The second function simply returns the length of a given chain.

<<gz0>>=
processChain <- function(protein, i) {
	chain <- newKnot(protein[[i]])
	chain <- closeAndProject( chain )
	return( computeInvariant(chain, 'HOMFLY') )
}        

lengthChain <- function(protein, i) return( nrow(protein[[i]]))
@

Then, we will fetch from the PDB a protein having 2 chains (and we will perform gap finding) and we will compute for example the HOMFLY polynomial of each of them. Finally, we will merge the resulting list in a dataframe to obtain a handy report.
<<>>=
protein <- loadProtein('1AJC', join.gaps = FALSE, cutoff = 7)
str(protein)
chains <- names(protein)        
polynomials <- lapply( 1: length(chains) , 
		function(i) {
			ifelse(lengthChain(protein, i) > 6, processChain(protein, i), 1) } )
cbind(chains, polynomials)        
@
As we can see, the first chain of this protein has been split and resulted in a two unknotted subchains. The second chain instead bears a right-handed trefoil knot. As a final remark, notice that if we would have ignored the gap finding, we would have not found a knot in the first chain.
<<>>=
protein <- loadProtein('1AJC', join.gaps = TRUE)
str(protein)
chains <- names(protein)        
polynomials <- lapply( 1: length(chains) , 
		function(i) {
			ifelse(lengthChain(protein, i) > 6, processChain(protein, i), 1) } )
cbind(chains, polynomials)        
@



%<<options,results=hide,echo=FALSE>>=
%options(digits=3)
%@  
%Both can be loaded with the following commands.

%<<loading,results=hide>>=
%library(bio3d)
%pdb.k <- fileImport(system.file("extdata/2K0A.pdb", package="Rknots"))
%pdb.a <- fileImport(system.file("extdata/1AJC_chainA.pdb", package="Rknots"))
%@
%or fetched directly from the Protein Data Bank
%<<loading3web, eval = FALSE>>=
%pdb.k <- fileImport("2k0a")
%@
%notice that \Rfunction{fileImport} is not case sensitive for convenience.





\section{Session Info}
<<session>>=
sessionInfo()
@

\begin{thebibliography}{}
\bibitem{CR}{Comoglio F., Rinaldi M., A Topological Framework for the Computation of the HOMFLY Polynomial and Its Application to Proteins. {\it PLoS ONE}, 6(4), e18693}
\bibitem{Rolfsen}{The Rolfsen Knot Table on Knot Atlas, \url{http://www.math.toronto.edu/~drorbn/KAtlas/Knots}}
\bibitem{Reidemeister}{Reidemeister K. (1926), Abh Math Sem Univ Hamburg 5: 24-32.}
\bibitem{Alexander}{Alexander J.W. and Briggs G.B. (1926) On types of knotted curves. {\it Ann of Math},  28, 562-586.}
\bibitem{vanRoon}{van Roon A.M.,  Loening N.M.,  Obayashi E.,  Yang J.C.,  Newman A.J.,  Hernandez H.,  Nagai K. and  Neuhaus D., (2008) Solution structure of the U2 snRNP protein Rds3p reveals a knotted zinc-finger motif, {\it Proc Natl Acad Sci USA}, 105, 9621-9626.}
\bibitem{rgl}{Adler D., Murdoch D., rgl: 3D visualization device system (OpenGL). {\sf R} package version 0.92.798}
  




\end{thebibliography}
\end{document}
